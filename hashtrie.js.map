{"version":3,"sources":["hashtrie.js"],"names":[],"mappings":"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","file":"hashtrie.js","sourcesContent":["var hashtrie = {};\n\nvar constant = x => () => x;\n\n/* Configuration\n ******************************************************************************/\nvar SIZE = 4;\n\nvar BUCKET_SIZE = Math.pow(2, SIZE);\n\nvar mask = BUCKET_SIZE - 1;\n\n/* Nothing\n ******************************************************************************/\nvar nothing = ({});\n\n/* Bit Ops\n ******************************************************************************/\nvar hashFragment = (shift, h) =>\n    (h >>> shift) & mask;\n\n/* Hashing\n ******************************************************************************/\n/**\n\tGet 32 bit hash of string.\n\t\n\tBased on:\n\thttp://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n */\nconst hash = hashtrie.hash = str => {\n    if (typeof str === 'number')\n        return str;\n    \n    let hash = 0;\n    for (let i = 0, len = str.length; i < len; i = i + 1) {\n        const c = str.charCodeAt(i);\n        hash = (((hash << 5) - hash) + c) | 0;\n    }\n    return hash;\n};\n\n/* Node Structures\n ******************************************************************************/\nfunction Map(root) {\n    this.root = root;\n};\n\nconst LEAF = 1;\nconst COLLISION = 2;\nconst INTERNAL = 3;\n\n/**\n\tEmpty node.\n */\nconst empty = { __hashtrie_empty: true };\n\nconst isEmptyNode = x =>\n    x === empty || (x && x.__hashtrie_empty);\n\n/**\n\tLeaf holding a value.\n\t\n\t@member hash Hash of key.\n\t@member key Key.\n\t@member value Value stored.\n */\nfunction Leaf(hash, key, value) {\n    this.type = LEAF;\n    this.hash = hash;\n    this.key = key;\n    this.value = value;\n};\n\n/**\n\tLeaf holding multiple values with the same hash but different keys.\n\t\n\t@member hash Hash of key.\n\t@member children Array of collision nodes.\n */\nfunction Collision(hash, children) {\n    this.type = COLLISION;\n    this.hash = hash;\n    this.children = children;\n};\n\n/**\n\tInternal node\n\t\n\t@member count Number of children.\n\t@member children Array of child nodes.\n */\nfunction InternalNode(count, children) {\n    this.type = INTERNAL;\n    this.count = count;\n    this.children = children;\n};\n\n/* Array ops\n ******************************************************************************/\n/**\n\tSet a value in an array.\n\t\n\tReturns copy of the array with value set.\n\t\n\t@param at Index to set.\n\t@param v Value.\n\t@param arr Array.\n */\nconst arrayUpdate = (at, v, arr) => {\n    const len = arr.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; ++i) \n        out[i] = arr[i];\n    out[at] = v;\n    return out;\n};\n\n/**\n\tRemove a value from an array.\n\t\n\t@param at Index to remove.\n\t@param arr Array.\n */\nvar arrayRemove = (at, arr) =>\n    arrayUpdate(at, undefined, arr);\n\n/**\n\tRemove a value from an array.\n\t\n\t@param at Index to remove.\n\t@param arr Array.\n*/\nconst arraySpliceOut = (at, arr) => {\n    const len = arr.length;\n    const out = new Array(len - 1);\n    let i = 0, g = 0;\n    while (i < at)\n        out[g++] = arr[i++];\n    ++i;\n    while (i < len)\n        out[g++] = arr[i++];\n    return out;\n};\n\n/* \n ******************************************************************************/\n/**\n\tCreate an internal node with one child\n */\nvar create1Internal = (h, n) => {\n    var children = new Array(BUCKET_SIZE);\n    children[h] = n;\n    return new InternalNode(1, children);\n};\n\n/**\n\tCreate an internal node with two children\n */\nvar create2Internal = (h1, n1, h2, n2) => {\n    var children = new Array(BUCKET_SIZE);\n    children[h1] = n1;\n    children[h2] = n2;\n    return new InternalNode(2, children);\n};\n\n/**\n\tMerge two leaf nodes.\n\t\n\t@param shift Current shift.\n\t@param h1 Hash of node 1.\n\t@param n1 Node 1.\n\t@param h2 Hash of node 2.\n\t@param n2 Node 2.\n */\nvar mergeLeaves = (shift, h1, n1, h2, n2) => {\n    if (h1 === h2)\n        return new Collision(h1, [n2, n1]);\n        \n    const subH1 = hashFragment(shift, h1);\n    const subH2 = hashFragment(shift, h2);\n    return subH1 === subH2\n        ?create1Internal(subH1, mergeLeaves(shift + SIZE, n1, n2))\n        :create2Internal(subH1, n1, subH2, n2);\n};\n\n/**\n\tUpdate an entry in a collision list.\n */\nconst updateCollisionList = (h, list, f, k) => {\n    let target;\n    let i = 0;\n    for (const len = list.length; i < len; ++i) {\n        const child = list[i];\n        if (child.key === k) {\n            target = child;\n            break;\n        }\n    }\n    \n    const v = target ? f(target.value) : f();\n    return v === nothing\n        ?arraySpliceOut(i, list)\n        :arrayUpdate(i, new Leaf(h, k, v), list);\n};\n\n/* Lookups\n ******************************************************************************/\nvar _lookup = (node, h, k) => {\n    let shift = 0;\n    while (true) switch (node.type) {\n    case LEAF:\n    {\n        return k === node.key ? node.value : nothing;\n    }   \n    case COLLISION:\n    {\n        if (h === node.hash) {\n            const children = node.children;\n            for (let i = 0, len = children.length; i < len; ++i) {\n                const child = children[i];\n                if (k === child.key)\n                    return child.value;\n            }\n        }\n        return nothing;\n    }  \n    case INTERNAL:\n    {\n        node = node.children[hashFragment(shift, h)];\n        if (node) {\n            shift += SIZE;\n            break;\n        } else {\n            return nothing;\n        }\n    }   \n    default:\n        return nothing;\n    }\n};\n\n/* Editing\n ******************************************************************************/\nempty._modify = function(shift, f, h, k) {\n    const v = f()\n    return v === nothing ? empty : new Leaf(h, k, v);\n};\n\n\nLeaf.prototype._modify = function(shift, f, h, k) {\n   if (k === this.key) {\n        const v = f(this.value);\n        return v === nothing ? empty : new Leaf(h, k, v);\n    }\n    const v = f();\n    return v === nothing\n        ?this\n        :mergeLeaves(shift, this.hash, this, h, new Leaf(h, k, v));\n};\n\nCollision.prototype._modify = function(shift, f, h, k) {\n    if (h === this.hash) {\n        const list = updateCollisionList(this.hash, this.children, f, k);\n        return list.length > 1\n            ?new Collision(this.hash, list)\n            :list[0]; // collapse single element collision list\n    }\n    const v = f();\n    return v === nothing\n        ?this\n        :mergeLeaves(shift, this.hash, this, h, new Leaf(h, k, v));\n};\n\nInternalNode.prototype._modify = function(shift, f, h, k) {\n    var frag = hashFragment(shift, h);\n    var child = this.children[frag] || empty;\n    var newChild = child._modify(shift + SIZE, f, h, k);\n    \n    if (isEmptyNode(child) && !isEmptyNode(newChild)) { // added\n        return new InternalNode(\n            this.count + 1,\n            arrayUpdate(frag, newChild, this.children))\n    }\n    \n    if (!isEmptyNode(child) && isEmptyNode(newChild)) { // removed\n        return this.count - 1 <= 0\n            ?empty\n            :new InternalNode(\n                this.count - 1,\n                arrayRemove(frag, this.children));\n    }\n            \n    // modified\n    return new InternalNode(\n        this.count,\n        arrayUpdate(frag, newChild, this.children));\n};\n\n/*\n ******************************************************************************/\n/**\n\tIs an object a hashtrie?\n */\nhashtrie.isHashTrie = m =>\n    (m instanceof Map);\n\n/* Queries\n ******************************************************************************/\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n    \n    Returns the value or `alt` if none.\n*/\nconst tryGetHash = hashtrie.tryGetHash = (alt, hash, key, map) => {\n    const v = _lookup(map.root, hash, key);\n    return v === nothing ? alt : v;\n};\n\nMap.prototype.tryGetHash = function(hash, key, alt) {\n    return tryGetHash(alt, hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n    \n    @see `tryGetHash`\n*/\nconst tryGet = hashtrie.tryGet = (alt, key, map) =>\n    tryGetHash(alt, hash(key), key, map);\n\nMap.prototype.tryGet = function(key, alt) {\n    return tryGet(alt, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n    \n    Returns the value or `undefined` if none.\n*/\nconst getHash = hashtrie.getHash = (hash, key, map) =>\n    tryGetHash(undefined, hash, key, map);\n\nMap.prototype.getHash = function(hash, key, alt) {\n    return getHash(hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n    \n    @see `get`\n*/\nconst get = hashtrie.get = (key, map) =>\n    tryGet(undefined, key, map);\n\nMap.prototype.get = function(key, alt) {\n    return tryGet(alt, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/\nconst hasHash = hashtrie.has = (hash, key, map) =>\n    tryGetHash(nothing, hash, key, map) !== nothing;\n\nMap.prototype.hasHash = function(hash, key) {\n    return hasHash(hash, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/\nconst has = hashtrie.has = (key, map) =>\n    hasHash(hash(key), key, map);\n    \nMap.prototype.has = function(key) {\n    return has(key, this);\n};\n\n/**\n    Empty node.\n*/\nhashtrie.empty = new Map(empty);\n\n/**\n    Does `map` contain any elements?\n*/\nconst isEmpty = hashtrie.isEmpty = (map) =>\n    !!isEmptyNode(map.root);\n    \nMap.prototype.isEmpty = function() {\n    return isEmpty(this);\n};\n\n/* Updates\n ******************************************************************************/\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n    \n    `f` is invoked with the current value for `k` if it exists,\n    or no arguments if no such value exists. `modify` will always either\n    update or insert a value into the map.\n    \n    Returns a map with the modified value. Does not alter `map`.\n*/\nconst modifyHash = hashtrie.modifyHash = (f, hash, key, map) =>\n    new Map(map.root._modify(0, f, hash, key));\n\nMap.prototype.modifyHash = function(hash, key, f) {\n    return modifyHash(f, hash, key, this);\n};\n\n/**\n    Alter the value stored for `key` in `map` using function `f` using \n    internal hash function.\n    \n    @see `modifyHash`\n*/\nconst modify = hashtrie.modify = (f, key, map) =>\n    modifyHash(f, hash(key), key, map);\n\nMap.prototype.modify = function(key, f) {\n    return modify(f, key, this);\n};\n\n/**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nconst setHash = hashtrie.setHash = (value, hash, key, map) =>\n    modifyHash(constant(value), hash, key, map);\n\nMap.prototype.setHash = function(hash, key, value) {\n    return setHash(value, hash, key, this);\n};\n\n/**\n    Store `value` for `key` in `map` using internal hash function.\n      \n    @see `setHash`\n*/\nconst set = hashtrie.set = (value, key, map) =>\n    setHash(value, hash(key), key, map);\n\nMap.prototype.set = function(key, value) {\n    return set(value, key, this);\n};\n\n/**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/\nconst del = constant(nothing);\nconst removeHash = hashtrie.removeHash = (hash, key, map) =>\n    modifyHash(del, hash, key, map);\n\nMap.prototype.removeHash = Map.prototype.deleteHash = function(hash, key) {\n    return removeHash(hash, key, this);\n};\n\n/**\n    Remove the entry for `key` in `map` using internal hash function.\n    \n    @see `removeHash`\n*/\nconst remove = hashtrie.remove = (key, map) =>\n    removeHash(hash(key), key, map);\n\nMap.prototype.remove = Map.prototype.delete = function(key) {\n    return remove(key, this);\n};\n\n/* Fold\n ******************************************************************************/\nLeaf.prototype._fold = function(f, z) {\n    return f(z, this.value, this.key);\n};\n\nCollision.prototype._fold = function(f, z) {\n    return this.children.reduce((p, c) => f(p, c.value, c.key), z);\n};\n\nInternalNode.prototype._fold = function(f, z) {\n    const children = this.children;\n    for (let i = 0, len = children.length; i < len; ++i) {\n        const c = children[i];\n        if (c && c._fold)\n            z = c instanceof Leaf\n                ?f(z, c.value, c.key)\n                :c._fold(f, z);\n    } \n    return z;\n};\n\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n    \n    @param f Function mapping previous value and key value object to new value.\n    @param z Starting value.\n    @param m HAMT\n*/\nconst fold = hashtrie.fold = (f, z, m) =>\n    isEmptyNode(m.root) ? z : m.root._fold(f, z);\n\nMap.prototype.fold = function(f, z) {\n    return fold(f, z, this);\n};\n\n/* Aggregate\n ******************************************************************************/\n/**\n    Get the number of entries in `map`.\n*/\nlet inc = x => x + 1;\nconst count = hashtrie.count = map =>\n    fold(inc, 0, map);\n\nMap.prototype.count = function() {\n    return count(this);\n};\n\n/**\n    Get array of all key value pairs as arrays of [key, value] in `map`.\n \n    Order is not guaranteed.\n*/\nconst buildPairs = (p, value, key) => { p.push([key, value]); return p; };\nconst pairs = hashtrie.pairs = map =>\n    fold(buildPairs, [], m);\n\nMap.prototype.pairs = function() {\n    return count(this);\n};\n\n/**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/\nconst buildKeys = (p, _, key) => { p.push(key); return p; };\nconst keys = hashtrie.keys = m =>\n    fold(buildKeys, [], m);\n\nMap.prototype.keys = function() {\n    return keys(this);\n};\n\n/**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/\nconst buildValues = (p, value) => { p.push(value); return p; };\nconst values = hashtrie.values = m =>\n    fold(buildValues, [], m);\n\nMap.prototype.values = function() {\n    return values(this);\n};\n\n\n/* Export\n ******************************************************************************/\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = hashtrie;\n} else if (typeof define === 'function' && define.amd) {\n    define('hashtrie', [], () => hashtrie);\n} else {\n    this.hashtrie = hashtrie;\n}\n"],"sourceRoot":"/source/"}