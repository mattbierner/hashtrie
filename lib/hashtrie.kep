/**
 * @fileOverview Hash Trie.
 *  * 
 * Data structure can store any value except null.
 */
package(
    hash
    
    empty
    
    isHashTrie

// Queries
    tryGetHash
    tryGet
    
    getHash
    get
    
    hasHash
    has
    
// Updates
    setHash
    set
    
    modifyHash
    modify
    
    removeHash
    remove

// Aggregate
    fold
    pairs
    count
    keys
    values)
{
/* Configuration
 ******************************************************************************/
var size = 4;

var BUCKET_SIZE = Math.pow(2, size);

var mask = BUCKET_SIZE - 1;

/*
 ******************************************************************************/
var constant = \x -> \() -> x;

/* Nothing
 ******************************************************************************/
var nothing = ({});

var isNothing = \x -> x === nothing;

var maybe = \val alt ->
    ?isNothing val
        :alt
        :val;

/* Bit Ops
 ******************************************************************************/
var hashFragment = \shift h ->
    (h >>> shift) & mask;

/* Hashing
 ******************************************************************************/
/**
 * Get 32 bit hash of string.
 * 
 * Based on:
 * http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
 */
hash = \str -> {
    if (typeof str === 'number')
        return str;
    
    var hash = 0;
    for (var i = 0, len = str.length; i < len; i = i + 1)
    with char = str.charCodeAt(i) in {
        hash = (((hash << 5) - hash) + char) | 0;
    }
    return hash;
};

/* Node Structures
 ******************************************************************************/
/**
 * Empty node.
 */
empty = null;

/**
 * Leaf holding a value.
 * 
 * @member hash Hash of key.
 * @member key Key.
 * @member value Value stored.
 */
var Leaf = function \hash key value =self-> {
    self.hash = hash;
    self.key = key;
    self.value = value;
};

/**
 * Leaf holding multiple values with the same hash but different keys.
 * 
 * @member hash Hash of key.
 * @member list Array of key value pairs.
 */
var Collision = function \hash list =self-> {
    self.hash = hash;
    self.list = list;
};

/**
 * Internal node
 * 
 * @member count Number of children.
 * @member children Array of child nodes.
 */
var InternalNode = function \count children =self-> {
    self.count = count;
    self.children = children;
};

/* 
 ******************************************************************************/
var isEmpty = (!);

/**
 * Set a value in an array.
 * 
 * Returns copy of the array with value set.
 * 
 * @param at Index to set.
 * @param v Value.
 * @param arr Array.
 */
var arrayUpdate = \at v arr -> {
    var out = arr.slice();
    out.(at) = v;
    return out;
};

/**
 * Remove a value from an array.
 * 
 * @param at Index to remove.
 * @param arr Array.
 */
var arrayRemove = \at arr -> {
    var out = arr.slice();
    delete out.(at);
    return out;
};

/**
 * Create an internal node with one child
 */
var create1Internal = \h n -> {
    var children = [];
    children.(h) = n;
    return new InternalNode(1, children);
};

/**
 * Create an internal node with two children
 */
var create1Internal = \h1 n1 h2 n2 -> {
    var children = [];
    children.(h1) = n1;
    children.(h2) = n2;
    return new InternalNode(2, children);
};

/**
 * Merge two leaf nodes.
 * 
 * @param shift Current shift.
 * @param n2 Node.
 * @param n2 Node
 */
var mergeLeaves = \shift n1 n2 -> let
    h1 = n1.hash,
    h2 = n2.hash
in
    ?h1 === h2
        :new Collision(h1, [n2, n1])
        :let
            subH1 = hashFragment(shift, h1),
            subH2 = hashFragment(shift, h2)
        in
            ?subH1 === subH2
                :create1Internal(subH1, mergeLeaves(shift + size, n1, n2)),
                :create2Internal(subH1, n1, subH2, n2);
/**
 * Update an entry in a collision list.
 */
var updateCollisionList = \list f k ->
    ? !list.length
        :[]
        :let first = list.(0), rest = list.slice(1) in
            ?first.key === k
                :let v = f(first) in
                    ?isNothing v
                        :rest
                        :[v].concat(rest)
                :[first].concat(updateCollisionList(rest, f, k));

/* Lookups
 ******************************************************************************/
var lookup;

/**
 * Leaf::get
 */
Leaf.prototype.get = \_ _ k =self->
    ?k === self.key
        :self.value
        :nothing;

/**
 * Collision::get
 */
Collision.prototype.get = \_ _ k =self-> {
    for (var i = 0, len = self.list.length; i < len; i = i + 1)
    with {key value} = self.list.(i) in {
        if (k === key)
            return value;
    }
    return nothing;
};

/**
 * InternalNode::get
 */
InternalNode.prototype.get = \shift h k =self-> let
    frag = hashFragment(shift, h),
    child = self.children.(frag)
in
    lookup(shift + size, h, k, child);

lookup = \shift h k n ->
    ?isEmpty n
        :nothing
        :n.get(shift, h, k);

/* Editing
 ******************************************************************************/
var alter;

/**
 * empty::alter
 */
var alterEmpty = \_ f h k -> let
    v = f()
in
    ?isNothing v
        :empty
        :new Leaf(h, k, v);

/**
 * Leaf::modify
 */
Leaf.prototype.modify = \shift f h k =self->
    ?k === self.key
        :let v = f(self.value) in
            ?isNothing v
                :empty
                :new Leaf(h, k, v)
        :let v = f() in
            ?isNothing v
                :self
                :mergeLeaves(shift, self, new Leaf(h, k, v));

/**
 * Collision::modify
 */
Collision.prototype.modify = \shift f h k =self-> let
    list = updateCollisionList(self.list, f, k)
in
    ?list.length > 1
        :new Collision(self.hash, list)
        :list.(0);

/**
 * InternalNode::modify
 */
InternalNode.prototype.modify = \shift f h k =self-> let
    frag = hashFragment(shift, h),
    child = self.children.(frag),
    newChild = alter(shift + size, f, h, k, child)
in
    ? isEmpty child && !isEmpty newChild
         // added
        :new InternalNode(
            self.count + 1,
            arrayUpdate(frag, newChild, self.children))

        :? !isEmpty child && isEmpty newChild
             // removed
            :?self.count - 1 <= 0
                :newChild
                :new InternalNode(
                    self.count - 1,
                    arrayRemove(frag, self.children))
            
            // modified
            :new InternalNode(
                self.count,
                arrayUpdate(frag, newChild, self.children));

alter = \shift f h k n ->
    ?isEmpty n
        :alterEmpty(shift, f, h, k)
        :n.modify(shift, f, h, k);

/*
 ******************************************************************************/
/**
 * Is an object a hashtrie?
 */
isHashTrie = \m ->
    (  m === empty
    || m instanceof Leaf
    || m instanceof InternalNode
    || m instanceof Collision);

/* Queries
 ******************************************************************************/
/**
 * Lookup a value.
 * 
 * Returns the value stored for the given hash and key, or alt if none.
 * 
 * @param alt Fallback value.
 * @param h 32 bit hash.
 * @param k Key.
 * @param m Hashtrie
 */
tryGetHash = \alt h k m  ->
    maybe(lookup(0, h, k, m), alt);

/**
 * Lookup a value using the internal `hash`.
 * 
 * @see getHash
 */
tryGet = \alt k m ->
    tryGetHash(alt, hash k, k, m);

/**
 * Lookup a value.
 * 
 * Returns the value stored for the given hash an key or null if none.
 * 
 * @param h 32 bit hash.
 * @param k Key.
 * @param m Hashtrie
 */
getHash = \h k m -> maybe(lookup(0, h, k, m), null);

/**
 * Lookup a value using the internal `hash`.
 * 
 * @see getHash
 */
get = \k m -> getHash(hash k, k, m);

/**
 * Does an entry exist?
 * 
 * @param h 32 bit hash.
 * @param k Key.
 * @param m Hashtrie
 */
hasHash = \h k m ->
    !isNothing lookup(0, h, k, m);

/**
 * Check if a an entry exists using internal `hash`
 * 
 * @see hashHash
 */
has = \k m ->
    hasHash(hash k, k, m);

/* Single Updates
 ******************************************************************************/
/**
 * Modify the value stored for a hash.
 * 
 * Returns the modified data structure. The input `m` is not modified.
 * 
 * @param h 32 bit hash.
 * @param k Key.
 * @param f Function mapping current value to new value.
 * @param m Hashtrie
 */
modifyHash = \h k f m ->
    alter(0, f, h, k, m);

/**
 * Store a value using the internal `hash` function to calculate the hash from `key`
 * 
 * @see modifyHash
 */
modify = \k f m ->
    modifyHash(hash k, k, f, m);

/**
 * Store a value with an explicit hash.
 * 
 * @param h 32 bit hash.
 * @param k Key.
 * @param v Value to store.
 * @param m Hashtrie
 */
setHash = \h k v m ->
    modifyHash(h, k, constant v, m);

/**
 * Store a value using the internal `hash` function to calculate the hash from `key`
 * 
 * @see setHash
 */
set = \k v m ->
    setHash(hash k, k, v, m);

/**
 * Delete a value with an explicit hash.
 * 
 * @param m Hashtrie
 * @param h 32 bit hash.
 * @param k Key.
 */
removeHash = let del = constant nothing in
    \h k m ->
        modifyHash(h, k, del, m);

/**
 * Delete a value using the internal `hash` function to calculate the hash from `key`
 * 
 * @see removeHash
 */
remove = \k m ->
    removeHash(hash k, k, m);

/* Fold
 ******************************************************************************/
/**
 * Leaf::fold
 */
Leaf.prototype.fold = \f z =self->
    f(z, self);

/**
 * Collision::fold
 */
Collision.prototype.fold = \f z =self->
    self.list.reduce(f, z);

/**
 * InternalNode::get
 */
InternalNode.prototype.fold = \f z =self->
    self.children.reduce(fold@f, z);

/**
 * Visit every entry in the map, aggregating data.
 * 
 * Order of nodes is not guaranteed.
 * 
 * @param f Function mapping previous value and key value object to new value.
 * @param z Starting value.
 * @param m Hashtrie
 */
fold = \f z m ->
    ?isEmpty m
        :z
        :m.fold(f, z);

/* Aggregate
 ******************************************************************************/
/**
 * Get the number of entries.
 */
count = fold@((+)@1, 0);

/**
 * Get array of all key value pairs as arrays of [key, value].
 * 
 * Order is not guaranteed.
 */
pairs = let build = \p {key value} -> { p.push [key, value]; return p; } in
    \m ->
        fold(build, [], m);

/**
 * Get array of all keys.
 * 
 * Order is not guaranteed.
 */
keys = let build = \p {key} -> { p.push key; return p; } in
    \m ->
        fold(build, [], m);

/**
 * Get array of all values.
 * 
 * Order is not guaranteed, duplicates will be preserved.
 */
values = let build = \p {value} -> { p.push value; return p; } in
    \m ->
        fold(build, [], m);

}